<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Ant Colony Optimization - TSP Solver</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --background: hsl(210, 20%, 98%);
            --foreground: hsl(222.2, 47.4%, 11.2%);
            --card: hsl(0, 0%, 100%);
            --card-foreground: hsl(222.2, 47.4%, 11.2%);
            --primary: hsl(221.2, 83.2%, 53.3%);
            --primary-foreground: hsl(210, 40%, 98%);
            --secondary: hsl(210, 40%, 96.1%);
            --secondary-foreground: hsl(222.2, 47.4%, 11.2%);
            --muted: hsl(210, 40%, 96.1%);
            --muted-foreground: hsl(215.4, 16.3%, 46.9%);
            --accent: hsl(262.1, 83.3%, 57.8%);
            --success: hsl(142.1, 76.2%, 36.3%);
            --destructive: hsl(0, 84.2%, 60.2%);
            --border: hsl(214.3, 31.8%, 91.4%);
            --input: hsl(214.3, 31.8%, 91.4%);
            --ring: hsl(221.2, 83.2%, 53.3%);
            --radius: 0.75rem;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--background);
            color: var(--foreground);
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            text-align: center;
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border);
            background: var(--card);
        }

        header h1 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--foreground);
            margin-bottom: 0.25rem;
            letter-spacing: -0.02em;
        }

        header p {
            font-size: 0.95rem;
            color: var(--muted-foreground);
        }

        /* Horizontal Control Bar */
        .control-bar {
            background: var(--card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
            z-index: 100;
        }

        /* Notification Banner */
        .notification-banner {
            background: linear-gradient(135deg, hsl(221.2, 83.2%, 53.3%), hsl(262.1, 83.3%, 57.8%));
            color: white;
            padding: 1rem 2rem;
            display: none;
            justify-content: space-between;
            align-items: center;
            animation: slideDown 0.3s ease-out;
            border-bottom: 1px solid var(--border);
        }

        .notification-banner.active {
            display: flex;
        }

        .notification-content {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .notification-spinner {
            width: 1rem;
            height: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .notification-text {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .notification-details {
            font-size: 0.875rem;
            opacity: 0.9;
        }

        .control-card {
            position: relative;
        }

        .control-trigger {
            padding: 0.625rem 1.25rem;
            background: var(--primary);
            color: var(--primary-foreground);
            border: none;
            border-radius: calc(var(--radius) - 0.125rem);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
        }

        .control-trigger:hover {
            background: hsl(221.2, 83.2%, 48%);
        }

        .control-trigger.secondary {
            background: var(--secondary);
            color: var(--secondary-foreground);
        }

        .control-trigger.secondary:hover {
            background: hsl(210, 40%, 92%);
        }

        .control-trigger.success {
            background: var(--success);
            color: white;
        }

        .control-trigger.success:hover {
            background: hsl(142.1, 76.2%, 32%);
        }

        .control-trigger.destructive {
            background: var(--destructive);
            color: white;
        }

        .control-trigger.destructive:hover {
            background: hsl(0, 84.2%, 55%);
        }

        .control-trigger:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-trigger svg {
            width: 1rem;
            height: 1rem;
        }

        .chevron {
            transition: transform 0.2s;
            margin-left: 0.25rem;
        }

        .chevron.rotated {
            transform: rotate(180deg);
        }

        /* Dropdown Panel */
        .dropdown-panel {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            padding: 1.5rem;
            min-width: 320px;
            max-width: 400px;
            z-index: 1000;
            display: none;
            animation: slideDown 0.2s ease-out;
        }

        .dropdown-panel.open {
            display: block;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Overlay - hidden, not needed anymore */
        .overlay {
            display: none !important;
        }

        .panel-header {
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .panel-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--foreground);
        }

        .panel-description {
            font-size: 0.8rem;
            color: var(--muted-foreground);
            margin-top: 0.25rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-label {
            display: block;
            margin-bottom: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--foreground);
        }

        .form-input,
        .form-select {
            width: 100%;
            height: 2.25rem;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--input);
            border-radius: calc(var(--radius) - 0.125rem);
            background: var(--background);
            font-size: 0.875rem;
            color: var(--foreground);
            transition: all 0.2s;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--ring);
            box-shadow: 0 0 0 3px hsla(221.2, 83.2%, 53.3%, 0.1);
        }

        .form-description {
            display: block;
            margin-top: 0.25rem;
            font-size: 0.8rem;
            color: var(--muted-foreground);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-wrapper input[type="checkbox"] {
            width: 1rem;
            height: 1rem;
            border: 1px solid var(--input);
            border-radius: 0.25rem;
            cursor: pointer;
        }

        .checkbox-wrapper label {
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
        }

        button.btn-panel {
            width: 100%;
            height: 2.25rem;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: calc(var(--radius) - 0.125rem);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .btn-panel.primary {
            background: var(--primary);
            color: var(--primary-foreground);
        }

        .btn-panel.primary:hover:not(:disabled) {
            background: hsl(221.2, 83.2%, 48%);
        }

        .btn-panel.secondary {
            background: var(--secondary);
            color: var(--secondary-foreground);
        }

        .btn-panel.secondary:hover:not(:disabled) {
            background: hsl(210, 40%, 92%);
        }

        .btn-panel:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .variant-info {
            background: hsl(221.2, 83.2%, 95%);
            border-left: 3px solid var(--primary);
            padding: 0.625rem;
            margin-top: 0.625rem;
            border-radius: 0.375rem;
            font-size: 0.8rem;
            line-height: 1.5;
            color: var(--foreground);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--muted);
            border-radius: calc(var(--radius) - 0.25rem);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .status-dot {
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 50%;
            background: var(--muted-foreground);
        }

        .status-dot.idle {
            background: var(--muted-foreground);
        }

        .status-dot.running {
            background: var(--success);
            animation: pulse-dot 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse-dot {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .status-details {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: var(--muted);
            border-radius: calc(var(--radius) - 0.25rem);
            font-size: 0.8rem;
            line-height: 1.6;
            color: var(--foreground);
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
        }

        .stat-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--muted-foreground);
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--foreground);
        }

        .canvas-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex: 1;
        }

        #tspCanvas {
            border: 1px solid var(--border);
            border-radius: calc(var(--radius) - 0.25rem);
            cursor: crosshair;
            background: var(--background);
            display: block;
            margin: 1rem auto 0;
            width: 100%;
            max-width: 100%;
        }

        .legend {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
            padding: 1rem;
            background: var(--muted);
            border-radius: calc(var(--radius) - 0.25rem);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--foreground);
        }

        .legend-color {
            width: 1rem;
            height: 1rem;
            border-radius: 0.25rem;
        }

        .chart-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            height: 350px;
        }

        @media (max-width: 1200px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .control-bar {
                padding: 0.75rem 1rem;
                gap: 0.5rem;
            }

            .main-content {
                padding: 1rem;
            }

            header h1 {
                font-size: 1.5rem;
            }

            header p {
                font-size: 0.85rem;
            }

            .dropdown-panel {
                min-width: 280px;
                left: auto;
                right: 0;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }

            .stat-value {
                font-size: 1.5rem;
            }

            #tspCanvas {
                height: 400px;
            }

            .chart-card {
                height: 300px;
            }
        }

        @media (max-width: 480px) {
            header h1 {
                font-size: 1.25rem;
            }

            .control-trigger {
                padding: 0.5rem 1rem;
                font-size: 0.8rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            #tspCanvas {
                height: 300px;
            }

            .form-input,
            .form-select {
                font-size: 16px; /* Prevent zoom on iOS */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Advanced Ant Colony Optimization</h1>
            <p>Interactive Traveling Salesman Problem Solver with Multiple ACO Variants</p>
        </header>

        <!-- Notification Banner -->
        <div class="notification-banner" id="notificationBanner">
            <div class="notification-content">
                <div class="notification-spinner"></div>
                <div>
                    <div class="notification-text" id="notificationText">Running optimization...</div>
                    <div class="notification-details" id="notificationDetails"></div>
                </div>
            </div>
        </div>

        <!-- Overlay for closing dropdowns -->
        <div class="overlay" id="overlay" onclick="closeAllPanels()"></div>

        <!-- Horizontal Control Bar -->
        <div class="control-bar">
            <!-- Problem Setup -->
            <div class="control-card">
                <button class="control-trigger secondary" onclick="togglePanel('setupPanel')">
                    <span>Setup</span>
                    <svg class="chevron" id="setupChevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
                <div class="dropdown-panel" id="setupPanel">
                    <div class="panel-header">
                        <h3 class="panel-title">Problem Setup</h3>
                        <p class="panel-description">Configure your TSP instance</p>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Number of Cities</label>
                        <input type="number" id="nCities" class="form-input" value="25" min="5" max="100">
                        <small class="form-description">Click canvas to add cities manually</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            <input type="checkbox" id="worldMapToggle" onchange="toggleWorldMap()" style="margin-right: 0.5rem;">
                            Show World Map Background
                        </label>
                        <small class="form-description">Scroll to zoom, drag to pan</small>
                    </div>
                    <div id="mapControls" style="display: none; gap: 0.5rem; margin-top: 0.5rem;">
                        <button class="btn-panel secondary" onclick="zoomIn()" style="flex: 1;">
                            Zoom In (+)
                        </button>
                        <button class="btn-panel secondary" onclick="zoomOut()" style="flex: 1;">
                            Zoom Out (-)
                        </button>
                        <button class="btn-panel secondary" onclick="resetMapView()" style="flex: 1;">
                            Reset View
                        </button>
                    </div>
                    <div class="button-group">
                        <button class="btn-panel secondary" onclick="generateRandomCities()">
                            Generate Random Cities
                        </button>
                        <button class="btn-panel secondary" onclick="clearCities()">
                            Clear All Cities
                        </button>
                    </div>
                </div>
            </div>

            <!-- Algorithm Settings -->
            <div class="control-card">
                <button class="control-trigger secondary" onclick="togglePanel('algorithmPanel')">
                    <span>Algorithm</span>
                    <svg class="chevron" id="algorithmChevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
                <div class="dropdown-panel" id="algorithmPanel">
                    <div class="panel-header">
                        <h3 class="panel-title">Algorithm Configuration</h3>
                        <p class="panel-description">Fine-tune ACO parameters</p>
                    </div>

                    <div class="form-group">
                        <label class="form-label">ACO Variant</label>
                        <select id="variant" class="form-select" onchange="updateVariantInfo()">
                            <option value="MMAS">Max-Min Ant System (MMAS)</option>
                            <option value="ACS">Ant Colony System (ACS)</option>
                            <option value="RANK">Rank-based Ant System</option>
                            <option value="AS">Basic Ant System (AS)</option>
                        </select>
                    </div>

                    <div id="variantInfo" class="variant-info"></div>

                    <div class="form-group">
                        <label class="form-label">Number of Ants</label>
                        <input type="number" id="nAnts" class="form-input" value="30" min="1" max="100">
                        <small class="form-description">More ants = better exploration</small>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Iterations</label>
                        <input type="number" id="nIterations" class="form-input" value="100" min="10" max="500">
                    </div>
                </div>
            </div>

            <!-- Parameters -->
            <div class="control-card">
                <button class="control-trigger secondary" onclick="togglePanel('parametersPanel')">
                    <span>Parameters</span>
                    <svg class="chevron" id="parametersChevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
                <div class="dropdown-panel" id="parametersPanel">
                    <div class="panel-header">
                        <h3 class="panel-title">Advanced Parameters</h3>
                        <p class="panel-description">Adjust algorithm parameters</p>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Alpha (α) - Pheromone Importance</label>
                        <input type="number" id="alpha" class="form-input" value="1.0" min="0" max="5" step="0.1">
                        <small class="form-description">Higher = more pheromone influence</small>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Beta (β) - Distance Importance</label>
                        <input type="number" id="beta" class="form-input" value="3.0" min="0" max="10" step="0.1">
                        <small class="form-description">Higher = prefer shorter distances</small>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Evaporation Rate (ρ)</label>
                        <input type="number" id="evaporationRate" class="form-input" value="0.1" min="0" max="1" step="0.01">
                        <small class="form-description">Higher = faster exploration</small>
                    </div>

                    <div class="form-group" id="q0Group">
                        <label class="form-label">Q0 - Exploitation vs Exploration (ACS)</label>
                        <input type="number" id="q0" class="form-input" value="0.9" min="0" max="1" step="0.05">
                        <small class="form-description">Higher = more exploitation</small>
                    </div>

                    <div class="form-group">
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="localSearch" checked>
                            <label for="localSearch">Enable 2-opt Local Search</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Spacer to push controls to the right -->
            <div style="flex: 1;"></div>

            <!-- Simple Status Indicator -->
            <div class="status-badge">
                <span class="status-dot idle" id="statusIndicator"></span>
                <span id="statusText">Idle</span>
            </div>

            <!-- Start Button -->
            <button class="control-trigger success" id="startBtn" onclick="startAlgorithm()">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <span>Start</span>
            </button>

            <!-- Stop Button -->
            <button class="control-trigger destructive" id="stopBtn" onclick="stopAlgorithm()" disabled>
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"></path>
                </svg>
                <span>Stop</span>
            </button>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Statistics Grid -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Best Distance</div>
                    <div class="stat-value" id="bestDistance">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Current Iteration</div>
                    <div class="stat-value" id="currentIteration">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Average Distance</div>
                    <div class="stat-value" id="avgDistance">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Cities</div>
                    <div class="stat-value" id="cityCount">0</div>
                </div>
            </div>

            <!-- Canvas Visualization -->
            <div class="canvas-card">
                <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600;">TSP Visualization</h3>
                <canvas id="tspCanvas" width="1600" height="600"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: hsl(0, 84.2%, 60.2%); border-radius: 50%;"></div>
                        <span>Cities</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: hsl(142.1, 76.2%, 36.3%); border-radius: 50%; border: 2px solid white;"></div>
                        <span>Start City</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: hsl(262.1, 83.3%, 57.8%); border-radius: 50%; border: 2px solid white;"></div>
                        <span>End City</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: hsl(221.2, 83.2%, 53.3%);"></div>
                        <span>Best Tour (Hamiltonian Cycle)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: hsla(221.2, 83.2%, 53.3%, 0.1);"></div>
                        <span>Pheromone Trails</span>
                    </div>
                </div>
            </div>

            <!-- Convergence Chart -->
            <div class="chart-card">
                <canvas id="convergenceChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let socket;
        let cities = [];
        let bestPath = null;
        let pheromones = null;
        let isRunning = false;
        let convergenceChart = null;
        let iterationData = {
            iterations: [],
            bestDistances: [],
            avgDistances: []
        };
        let currentOpenPanel = null;

        // Canvas setup
        const canvas = document.getElementById('tspCanvas');
        const ctx = canvas.getContext('2d');

        // World map background
        let worldMapEnabled = false;
        let worldMapImage = new Image();
        let worldMapLoaded = false;

        // Map zoom and pan state
        let mapZoom = 1.0;
        let mapOffsetX = 0;
        let mapOffsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastMapOffsetX = 0;
        let lastMapOffsetY = 0;

        // Load world map image
        worldMapImage.onload = function() {
            worldMapLoaded = true;
            console.log('Map loaded successfully');
            drawCanvas();
        };
        worldMapImage.onerror = function() {
            console.error('Failed to load map');
        };
        // Using world map (equirectangular projection)
        worldMapImage.src = 'https://upload.wikimedia.org/wikipedia/commons/8/83/Equirectangular_projection_SW.jpg';

        // Panel management
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const chevronId = panelId.replace('Panel', 'Chevron');
            const chevron = document.getElementById(chevronId);

            // Close currently open panel if different
            if (currentOpenPanel && currentOpenPanel !== panelId) {
                const prevPanel = document.getElementById(currentOpenPanel);
                const prevChevronId = currentOpenPanel.replace('Panel', 'Chevron');
                const prevChevron = document.getElementById(prevChevronId);
                if (prevPanel) prevPanel.classList.remove('open');
                if (prevChevron) prevChevron.classList.remove('rotated');
            }

            // Toggle the clicked panel
            if (panel.classList.contains('open')) {
                panel.classList.remove('open');
                chevron.classList.remove('rotated');
                currentOpenPanel = null;
            } else {
                panel.classList.add('open');
                chevron.classList.add('rotated');
                currentOpenPanel = panelId;
            }
        }

        function closeAllPanels() {
            const panels = document.querySelectorAll('.dropdown-panel');
            const chevrons = document.querySelectorAll('.chevron');

            panels.forEach(panel => panel.classList.remove('open'));
            chevrons.forEach(chevron => chevron.classList.remove('rotated'));
            currentOpenPanel = null;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeSocket();
            initializeChart();
            updateVariantInfo();
            resizeCanvas();
            drawCanvas();

            // Close dropdown panels when clicking outside
            document.addEventListener('click', function(e) {
                // Check if click is outside all dropdown panels and triggers
                const isInsidePanel = e.target.closest('.dropdown-panel');
                const isInsideTrigger = e.target.closest('.control-trigger');

                if (!isInsidePanel && !isInsideTrigger && currentOpenPanel) {
                    closeAllPanels();
                }
            });

            // Prevent dropdown panels from closing when clicking inside them
            const dropdownPanels = document.querySelectorAll('.dropdown-panel');
            dropdownPanels.forEach(panel => {
                panel.addEventListener('click', function(e) {
                    // Stop propagation to keep panel open when clicking inside
                    e.stopPropagation();
                });
            });

            // Canvas click handler for manual city placement
            canvas.addEventListener('click', function(e) {
                if (!isRunning && !isDragging) {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    cities.push([x, y]);
                    updateCityCount();
                    drawCanvas();
                }
            });

            // Map zoom with mouse wheel (only when map is enabled)
            canvas.addEventListener('wheel', function(e) {
                if (worldMapEnabled) {
                    e.preventDefault();

                    const zoomSpeed = 0.1;
                    const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
                    const newZoom = Math.max(0.5, Math.min(5.0, mapZoom + delta));

                    mapZoom = newZoom;
                    drawCanvas();
                }
            }, { passive: false });

            // Map pan with mouse drag (only when map is enabled)
            canvas.addEventListener('mousedown', function(e) {
                if (worldMapEnabled && e.button === 0) {
                    isDragging = true;
                    const rect = canvas.getBoundingClientRect();
                    dragStartX = e.clientX - rect.left;
                    dragStartY = e.clientY - rect.top;
                    lastMapOffsetX = mapOffsetX;
                    lastMapOffsetY = mapOffsetY;
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', function(e) {
                if (isDragging && worldMapEnabled) {
                    const rect = canvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;

                    mapOffsetX = lastMapOffsetX + (currentX - dragStartX);
                    mapOffsetY = lastMapOffsetY + (currentY - dragStartY);

                    drawCanvas();
                }
            });

            canvas.addEventListener('mouseup', function(e) {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = worldMapEnabled ? 'grab' : 'crosshair';
                }
            });

            canvas.addEventListener('mouseleave', function(e) {
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = worldMapEnabled ? 'grab' : 'crosshair';
                }
            });

            // Update cursor based on map state
            canvas.addEventListener('mouseenter', function(e) {
                canvas.style.cursor = worldMapEnabled ? 'grab' : 'crosshair';
            });

            // Handle window resize
            window.addEventListener('resize', function() {
                resizeCanvas();
                drawCanvas();
            });

            // Add input focus styling
            const inputs = document.querySelectorAll('.form-input, .form-select');
            inputs.forEach(input => {
                input.addEventListener('focus', function() {
                    this.select(); // Select all text when focused for easy editing
                });
            });
        });

        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 48; // Account for padding

            canvas.width = Math.min(1600, containerWidth);
            canvas.height = Math.min(600, Math.max(400, window.innerHeight * 0.4));
        }

        function initializeSocket() {
            socket = io();

            socket.on('connect', function() {
                console.log('Connected to server');
            });

            socket.on('iteration_update', function(data) {
                updateVisualization(data);
            });

            socket.on('algorithm_complete', function(data) {
                console.log('Algorithm complete', data);
                setRunningState(false);
                alert(`Optimization complete!\nBest distance: ${data.best_distance.toFixed(2)}`);
            });

            socket.on('algorithm_stopped', function(data) {
                console.log('Algorithm stopped');
                setRunningState(false);
            });

            socket.on('error', function(data) {
                console.error('Error:', data.message);
                alert('Error: ' + data.message);
                setRunningState(false);
            });
        }

        function initializeChart() {
            const chartCtx = document.getElementById('convergenceChart').getContext('2d');
            convergenceChart = new Chart(chartCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Best Distance',
                            data: [],
                            borderColor: 'hsl(142.1, 76.2%, 36.3%)',
                            backgroundColor: 'hsla(142.1, 76.2%, 36.3%, 0.1)',
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true
                        },
                        {
                            label: 'Average Distance',
                            data: [],
                            borderColor: 'hsl(221.2, 83.2%, 53.3%)',
                            backgroundColor: 'hsla(221.2, 83.2%, 53.3%, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Convergence Over Iterations',
                            font: { size: 16, weight: 600 },
                            color: 'hsl(222.2, 47.4%, 11.2%)'
                        },
                        legend: {
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Distance'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Iteration'
                            }
                        }
                    },
                    animation: {
                        duration: 0
                    }
                }
            });
        }

        function updateVariantInfo() {
            const variant = document.getElementById('variant').value;
            const infoDiv = document.getElementById('variantInfo');
            const q0Group = document.getElementById('q0Group');

            const variantInfoText = {
                'MMAS': 'Uses pheromone bounds [τ_min, τ_max] to prevent premature convergence. Only the best ant deposits pheromones.',
                'ACS': 'Uses pseudo-random proportional rule with Q0 parameter. Includes local pheromone updates during construction.',
                'RANK': 'Ranks ants by solution quality. Only top-ranked ants deposit pheromones with decreasing weights.',
                'AS': 'Original Ant System. All ants deposit pheromones proportional to solution quality.'
            };

            infoDiv.textContent = variantInfoText[variant];
            q0Group.style.display = variant === 'ACS' ? 'block' : 'none';
        }

        function generateRandomCities() {
            const nCities = parseInt(document.getElementById('nCities').value);
            cities = [];

            for (let i = 0; i < nCities; i++) {
                cities.push([
                    Math.random() * (canvas.width - 40) + 20,
                    Math.random() * (canvas.height - 40) + 20
                ]);
            }

            updateCityCount();
            drawCanvas();
        }

        function clearCities() {
            cities = [];
            bestPath = null;
            pheromones = null;
            updateCityCount();
            drawCanvas();
        }

        function updateCityCount() {
            document.getElementById('cityCount').textContent = cities.length;
        }

        function toggleWorldMap() {
            worldMapEnabled = document.getElementById('worldMapToggle').checked;
            console.log('World map enabled:', worldMapEnabled);

            const mapControls = document.getElementById('mapControls');

            // Reset zoom and pan when toggling map
            if (worldMapEnabled) {
                mapZoom = 1.0;
                mapOffsetX = 0;
                mapOffsetY = 0;
                canvas.style.cursor = 'grab';
                mapControls.style.display = 'flex';
            } else {
                canvas.style.cursor = 'crosshair';
                mapControls.style.display = 'none';
            }

            drawCanvas();
        }

        function zoomIn() {
            mapZoom = Math.min(5.0, mapZoom + 0.2);
            drawCanvas();
        }

        function zoomOut() {
            mapZoom = Math.max(0.5, mapZoom - 0.2);
            drawCanvas();
        }

        function resetMapView() {
            mapZoom = 1.0;
            mapOffsetX = 0;
            mapOffsetY = 0;
            drawCanvas();
        }

        function startAlgorithm() {
            if (cities.length < 3) {
                alert('Please add at least 3 cities');
                return;
            }

            // Close all panels when starting
            closeAllPanels();

            // Reset data
            iterationData = {
                iterations: [],
                bestDistances: [],
                avgDistances: []
            };
            convergenceChart.data.labels = [];
            convergenceChart.data.datasets[0].data = [];
            convergenceChart.data.datasets[1].data = [];
            convergenceChart.update();

            // Gather parameters
            const params = {
                cities: cities,
                variant: document.getElementById('variant').value,
                n_ants: parseInt(document.getElementById('nAnts').value),
                n_iterations: parseInt(document.getElementById('nIterations').value),
                alpha: parseFloat(document.getElementById('alpha').value),
                beta: parseFloat(document.getElementById('beta').value),
                evaporation_rate: parseFloat(document.getElementById('evaporationRate').value),
                q0: parseFloat(document.getElementById('q0').value),
                local_search: document.getElementById('localSearch').checked
            };

            setRunningState(true);
            socket.emit('start_aco', params);
        }

        function stopAlgorithm() {
            socket.emit('stop_aco');
        }

        function setRunningState(running) {
            isRunning = running;
            document.getElementById('startBtn').disabled = running;
            document.getElementById('stopBtn').disabled = !running;

            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const notificationBanner = document.getElementById('notificationBanner');

            if (running) {
                indicator.classList.remove('idle');
                indicator.classList.add('running');
                statusText.textContent = 'Running';
                notificationBanner.classList.add('active');
            } else {
                indicator.classList.remove('running');
                indicator.classList.add('idle');
                statusText.textContent = 'Idle';
                notificationBanner.classList.remove('active');
            }
        }

        function updateVisualization(data) {
            // Update stats
            document.getElementById('bestDistance').textContent = data.best_distance.toFixed(2);
            document.getElementById('currentIteration').textContent = data.iteration;
            document.getElementById('avgDistance').textContent = data.avg_distance.toFixed(2);

            // Update notification banner
            document.getElementById('notificationText').textContent = `Iteration ${data.iteration} - Optimizing...`;
            document.getElementById('notificationDetails').textContent =
                `Best: ${data.best_distance.toFixed(2)} | Iter Best: ${data.iteration_best.toFixed(2)} | Avg: ${data.avg_distance.toFixed(2)}`;

            // Update best path
            if (data.best_path) {
                bestPath = data.best_path;
            }

            // Update pheromones
            if (data.pheromones) {
                pheromones = data.pheromones;
            }

            // Update chart
            iterationData.iterations.push(data.iteration);
            iterationData.bestDistances.push(data.best_distance);
            iterationData.avgDistances.push(data.avg_distance);

            convergenceChart.data.labels = iterationData.iterations;
            convergenceChart.data.datasets[0].data = iterationData.bestDistances;
            convergenceChart.data.datasets[1].data = iterationData.avgDistances;
            convergenceChart.update();

            // Redraw canvas
            drawCanvas();
        }

        function drawCanvas() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw world map background if enabled with zoom and pan
            if (worldMapEnabled && worldMapLoaded) {
                ctx.save();
                ctx.globalAlpha = 0.4; // Make map semi-transparent

                // Calculate scaled dimensions
                const scaledWidth = canvas.width * mapZoom;
                const scaledHeight = canvas.height * mapZoom;

                // Apply zoom and pan transformations
                const x = mapOffsetX + (canvas.width - scaledWidth) / 2;
                const y = mapOffsetY + (canvas.height - scaledHeight) / 2;

                ctx.drawImage(worldMapImage, x, y, scaledWidth, scaledHeight);
                ctx.globalAlpha = 1.0; // Reset alpha
                ctx.restore();
            }

            if (cities.length === 0) {
                ctx.fillStyle = 'hsl(215.4, 16.3%, 46.9%)';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Click to add cities or generate random cities', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Draw pheromone trails
            if (pheromones && cities.length > 0) {
                const maxPheromone = Math.max(...pheromones.flat());

                for (let i = 0; i < cities.length; i++) {
                    for (let j = i + 1; j < cities.length; j++) {
                        const pheromone = pheromones[i][j];
                        const opacity = (pheromone / maxPheromone) * 0.3;

                        if (opacity > 0.01) {
                            ctx.strokeStyle = `hsla(221.2, 83.2%, 53.3%, ${opacity})`;
                            ctx.lineWidth = 1 + (opacity * 3);
                            ctx.beginPath();
                            ctx.moveTo(cities[i][0], cities[i][1]);
                            ctx.lineTo(cities[j][0], cities[j][1]);
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw best path (Hamiltonian Cycle)
            if (bestPath && bestPath.length > 0) {
                ctx.strokeStyle = 'hsl(221.2, 83.2%, 53.3%)';
                ctx.lineWidth = 3;
                ctx.beginPath();

                for (let i = 0; i < bestPath.length; i++) {
                    const cityIdx = bestPath[i];
                    const city = cities[cityIdx];

                    if (i === 0) {
                        ctx.moveTo(city[0], city[1]);
                    } else {
                        ctx.lineTo(city[0], city[1]);
                    }
                }

                // Close the Hamiltonian cycle (tour returns to start)
                const firstCity = cities[bestPath[0]];
                ctx.lineTo(firstCity[0], firstCity[1]);
                ctx.stroke();

                // Draw directional arrows along the path to show it's a cycle
                ctx.fillStyle = 'hsl(221.2, 83.2%, 53.3%)';
                for (let i = 0; i < bestPath.length; i++) {
                    const cityIdx = bestPath[i];
                    const nextIdx = bestPath[(i + 1) % bestPath.length];
                    const city = cities[cityIdx];
                    const nextCity = cities[nextIdx];

                    // Calculate midpoint
                    const midX = (city[0] + nextCity[0]) / 2;
                    const midY = (city[1] + nextCity[1]) / 2;

                    // Calculate angle
                    const angle = Math.atan2(nextCity[1] - city[1], nextCity[0] - city[0]);

                    // Draw arrow
                    const arrowSize = 8;
                    ctx.save();
                    ctx.translate(midX, midY);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-arrowSize, -arrowSize / 2);
                    ctx.lineTo(-arrowSize, arrowSize / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Draw cities with start/end indicators
            cities.forEach((city, idx) => {
                const isStart = bestPath && bestPath.length > 0 && idx === bestPath[0];
                const isEnd = bestPath && bestPath.length > 1 && idx === bestPath[bestPath.length - 1];

                // Determine city color and size
                let fillColor, radius;
                if (isStart) {
                    fillColor = 'hsl(142.1, 76.2%, 36.3%)'; // Green for start
                    radius = 10;
                } else if (isEnd) {
                    fillColor = 'hsl(262.1, 83.3%, 57.8%)'; // Purple for end
                    radius = 10;
                } else {
                    fillColor = 'hsl(0, 84.2%, 60.2%)'; // Red for regular cities
                    radius = 6;
                }

                // Draw city circle
                ctx.fillStyle = fillColor;
                ctx.beginPath();
                ctx.arc(city[0], city[1], radius, 0, 2 * Math.PI);
                ctx.fill();

                // Add white border for start/end cities
                if (isStart || isEnd) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Draw city number
                ctx.fillStyle = 'hsl(222.2, 47.4%, 11.2%)';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(idx.toString(), city[0], city[1] - 15);

                // Draw START/END labels
                if (isStart) {
                    ctx.fillStyle = 'hsl(142.1, 76.2%, 36.3%)';
                    ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    ctx.fillText('START', city[0], city[1] + 20);
                } else if (isEnd) {
                    ctx.fillStyle = 'hsl(262.1, 83.3%, 57.8%)';
                    ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    ctx.fillText('END', city[0], city[1] + 20);
                }
            });
        }
    </script>
</body>
</html>
